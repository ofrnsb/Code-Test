{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  INTERCEPTION_ROUTE_MARKERS: null,\n  isInterceptionRouteAppPath: null,\n  extractInterceptionRouteInformation: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  INTERCEPTION_ROUTE_MARKERS: function () {\n    return INTERCEPTION_ROUTE_MARKERS;\n  },\n  isInterceptionRouteAppPath: function () {\n    return isInterceptionRouteAppPath;\n  },\n  extractInterceptionRouteInformation: function () {\n    return extractInterceptionRouteInformation;\n  }\n});\nconst _apppaths = require(\"../../../shared/lib/router/utils/app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = [\"(..)(..)\", \"(.)\", \"(..)\", \"(...)\"];\nfunction isInterceptionRouteAppPath(path) {\n  // TODO-APP: add more serious validation\n  return path.split(\"/\").find(segment => INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n  let interceptingRoute, marker, interceptedRoute;\n  for (const segment of path.split(\"/\")) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n    if (marker) {\n      [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n      break;\n    }\n  }\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n  }\n  interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n  ;\n\n  switch (marker) {\n    case \"(.)\":\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === \"/\") {\n        interceptedRoute = `/${interceptedRoute}`;\n      } else {\n        interceptedRoute = interceptingRoute + \"/\" + interceptedRoute;\n      }\n      break;\n    case \"(..)\":\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === \"/\") {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n      }\n      interceptedRoute = interceptingRoute.split(\"/\").slice(0, -1).concat(interceptedRoute).join(\"/\");\n      break;\n    case \"(...)\":\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = \"/\" + interceptedRoute;\n      break;\n    case \"(..)(..)\":\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n      const splitInterceptingRoute = interceptingRoute.split(\"/\");\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n      }\n      interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join(\"/\");\n      break;\n    default:\n      throw new Error(\"Invariant: unexpected marker\");\n  }\n  return {\n    interceptingRoute,\n    interceptedRoute\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","module","INTERCEPTION_ROUTE_MARKERS","isInterceptionRouteAppPath","extractInterceptionRouteInformation","_export","target","all","name","enumerable","get","_apppaths","require","path","split","find","segment","m","startsWith","undefined","interceptingRoute","marker","interceptedRoute","Error","normalizeAppPath","slice","concat","join","splitInterceptingRoute","length"],"sources":["C:/Users/BNI/node_modules/next/dist/server/future/helpers/interception-routes.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    INTERCEPTION_ROUTE_MARKERS: null,\n    isInterceptionRouteAppPath: null,\n    extractInterceptionRouteInformation: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    INTERCEPTION_ROUTE_MARKERS: function() {\n        return INTERCEPTION_ROUTE_MARKERS;\n    },\n    isInterceptionRouteAppPath: function() {\n        return isInterceptionRouteAppPath;\n    },\n    extractInterceptionRouteInformation: function() {\n        return extractInterceptionRouteInformation;\n    }\n});\nconst _apppaths = require(\"../../../shared/lib/router/utils/app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = [\n    \"(..)(..)\",\n    \"(.)\",\n    \"(..)\",\n    \"(...)\"\n];\nfunction isInterceptionRouteAppPath(path) {\n    // TODO-APP: add more serious validation\n    return path.split(\"/\").find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n    let interceptingRoute, marker, interceptedRoute;\n    for (const segment of path.split(\"/\")){\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n        if (marker) {\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n            break;\n        }\n    }\n    if (!interceptingRoute || !marker || !interceptedRoute) {\n        throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n    }\n    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n    ;\n    switch(marker){\n        case \"(.)\":\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n            if (interceptingRoute === \"/\") {\n                interceptedRoute = `/${interceptedRoute}`;\n            } else {\n                interceptedRoute = interceptingRoute + \"/\" + interceptedRoute;\n            }\n            break;\n        case \"(..)\":\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n            if (interceptingRoute === \"/\") {\n                throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n            }\n            interceptedRoute = interceptingRoute.split(\"/\").slice(0, -1).concat(interceptedRoute).join(\"/\");\n            break;\n        case \"(...)\":\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n            interceptedRoute = \"/\" + interceptedRoute;\n            break;\n        case \"(..)(..)\":\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n            const splitInterceptingRoute = interceptingRoute.split(\"/\");\n            if (splitInterceptingRoute.length <= 2) {\n                throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n            }\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join(\"/\");\n            break;\n        default:\n            throw new Error(\"Invariant: unexpected marker\");\n    }\n    return {\n        interceptingRoute,\n        interceptedRoute\n    };\n}\n\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACF,CAAC,KAAKC,MAAM,CAACF,OAAO,GAAG;EACnBG,0BAA0B,EAAE,IAAI;EAChCC,0BAA0B,EAAE,IAAI;EAChCC,mCAAmC,EAAE;AACzC,CAAC,CAAC;AACF,SAASC,OAAOA,CAACC,MAAM,EAAEC,GAAG,EAAE;EAC1B,KAAI,IAAIC,IAAI,IAAID,GAAG,EAACV,MAAM,CAACC,cAAc,CAACQ,MAAM,EAAEE,IAAI,EAAE;IACpDC,UAAU,EAAE,IAAI;IAChBC,GAAG,EAAEH,GAAG,CAACC,IAAI;EACjB,CAAC,CAAC;AACN;AACAH,OAAO,CAACN,OAAO,EAAE;EACbG,0BAA0B,EAAE,SAAAA,CAAA,EAAW;IACnC,OAAOA,0BAA0B;EACrC,CAAC;EACDC,0BAA0B,EAAE,SAAAA,CAAA,EAAW;IACnC,OAAOA,0BAA0B;EACrC,CAAC;EACDC,mCAAmC,EAAE,SAAAA,CAAA,EAAW;IAC5C,OAAOA,mCAAmC;EAC9C;AACJ,CAAC,CAAC;AACF,MAAMO,SAAS,GAAGC,OAAO,CAAC,4CAA4C,CAAC;AACvE,MAAMV,0BAA0B,GAAG,CAC/B,UAAU,EACV,KAAK,EACL,MAAM,EACN,OAAO,CACV;AACD,SAASC,0BAA0BA,CAACU,IAAI,EAAE;EACtC;EACA,OAAOA,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,IAAI,CAAEC,OAAO,IAAGd,0BAA0B,CAACa,IAAI,CAAEE,CAAC,IAAGD,OAAO,CAACE,UAAU,CAACD,CAAC,CAAC,CAAC,CAAC,KAAKE,SAAS;AACrH;AACA,SAASf,mCAAmCA,CAACS,IAAI,EAAE;EAC/C,IAAIO,iBAAiB,EAAEC,MAAM,EAAEC,gBAAgB;EAC/C,KAAK,MAAMN,OAAO,IAAIH,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,EAAC;IAClCO,MAAM,GAAGnB,0BAA0B,CAACa,IAAI,CAAEE,CAAC,IAAGD,OAAO,CAACE,UAAU,CAACD,CAAC,CAAC,CAAC;IACpE,IAAII,MAAM,EAAE;MACR,CAACD,iBAAiB,EAAEE,gBAAgB,CAAC,GAAGT,IAAI,CAACC,KAAK,CAACO,MAAM,EAAE,CAAC,CAAC;MAC7D;IACJ;EACJ;EACA,IAAI,CAACD,iBAAiB,IAAI,CAACC,MAAM,IAAI,CAACC,gBAAgB,EAAE;IACpD,MAAM,IAAIC,KAAK,CAAE,+BAA8BV,IAAK,mFAAkF,CAAC;EAC3I;EACAO,iBAAiB,GAAG,CAAC,CAAC,EAAET,SAAS,CAACa,gBAAgB,EAAEJ,iBAAiB,CAAC,CAAC;EAAA;;EAEvE,QAAOC,MAAM;IACT,KAAK,KAAK;MACN;MACA,IAAID,iBAAiB,KAAK,GAAG,EAAE;QAC3BE,gBAAgB,GAAI,IAAGA,gBAAiB,EAAC;MAC7C,CAAC,MAAM;QACHA,gBAAgB,GAAGF,iBAAiB,GAAG,GAAG,GAAGE,gBAAgB;MACjE;MACA;IACJ,KAAK,MAAM;MACP;MACA,IAAIF,iBAAiB,KAAK,GAAG,EAAE;QAC3B,MAAM,IAAIG,KAAK,CAAE,+BAA8BV,IAAK,8DAA6D,CAAC;MACtH;MACAS,gBAAgB,GAAGF,iBAAiB,CAACN,KAAK,CAAC,GAAG,CAAC,CAACW,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,MAAM,CAACJ,gBAAgB,CAAC,CAACK,IAAI,CAAC,GAAG,CAAC;MAC/F;IACJ,KAAK,OAAO;MACR;MACAL,gBAAgB,GAAG,GAAG,GAAGA,gBAAgB;MACzC;IACJ,KAAK,UAAU;MACX;MACA,MAAMM,sBAAsB,GAAGR,iBAAiB,CAACN,KAAK,CAAC,GAAG,CAAC;MAC3D,IAAIc,sBAAsB,CAACC,MAAM,IAAI,CAAC,EAAE;QACpC,MAAM,IAAIN,KAAK,CAAE,+BAA8BV,IAAK,iEAAgE,CAAC;MACzH;MACAS,gBAAgB,GAAGM,sBAAsB,CAACH,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,MAAM,CAACJ,gBAAgB,CAAC,CAACK,IAAI,CAAC,GAAG,CAAC;MACzF;IACJ;MACI,MAAM,IAAIJ,KAAK,CAAC,8BAA8B,CAAC;EACvD;EACA,OAAO;IACHH,iBAAiB;IACjBE;EACJ,CAAC;AACL"},"metadata":{},"sourceType":"script","externalDependencies":[]}