{"ast":null,"code":"// tslint:disable:no-console\n\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/BNI/2023/learn/deptech/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  default: null,\n  matchesMiddleware: null,\n  createKey: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  default: function () {\n    return Router;\n  },\n  matchesMiddleware: function () {\n    return matchesMiddleware;\n  },\n  createKey: function () {\n    return createKey;\n  }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _removetrailingslash = require(\"./utils/remove-trailing-slash\");\nconst _routeloader = require(\"../../../client/route-loader\");\nconst _script = require(\"../../../client/script\");\nconst _iserror = /*#__PURE__*/_interop_require_wildcard._(require(\"../../../lib/is-error\"));\nconst _denormalizepagepath = require(\"../page-path/denormalize-page-path\");\nconst _normalizelocalepath = require(\"../i18n/normalize-locale-path\");\nconst _mitt = /*#__PURE__*/_interop_require_default._(require(\"../mitt\"));\nconst _utils = require(\"../utils\");\nconst _isdynamic = require(\"./utils/is-dynamic\");\nconst _parserelativeurl = require(\"./utils/parse-relative-url\");\nconst _resolverewrites = /*#__PURE__*/_interop_require_default._(require(\"./utils/resolve-rewrites\"));\nconst _routematcher = require(\"./utils/route-matcher\");\nconst _routeregex = require(\"./utils/route-regex\");\nconst _formaturl = require(\"./utils/format-url\");\nconst _detectdomainlocale = require(\"../../../client/detect-domain-locale\");\nconst _parsepath = require(\"./utils/parse-path\");\nconst _addlocale = require(\"../../../client/add-locale\");\nconst _removelocale = require(\"../../../client/remove-locale\");\nconst _removebasepath = require(\"../../../client/remove-base-path\");\nconst _addbasepath = require(\"../../../client/add-base-path\");\nconst _hasbasepath = require(\"../../../client/has-base-path\");\nconst _resolvehref = require(\"../../../client/resolve-href\");\nconst _isapiroute = require(\"../../../lib/is-api-route\");\nconst _getnextpathnameinfo = require(\"./utils/get-next-pathname-info\");\nconst _formatnextpathnameinfo = require(\"./utils/format-next-pathname-info\");\nconst _comparestates = require(\"./utils/compare-states\");\nconst _islocalurl = require(\"./utils/is-local-url\");\nconst _isbot = require(\"./utils/is-bot\");\nconst _omit = require(\"./utils/omit\");\nconst _interpolateas = require(\"./utils/interpolate-as\");\nconst _handlesmoothscroll = require(\"./utils/handle-smooth-scroll\");\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\nfunction matchesMiddleware(_x) {\n  return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n  _matchesMiddleware = _asyncToGenerator(function* (options) {\n    const matchers = yield Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const {\n      pathname: asPathname\n    } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some(m => new RegExp(m.regexp).test(asWithBasePathAndLocale));\n  });\n  return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n  const origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n  const origin = (0, _utils.getLocationOrigin)();\n  const hrefWasAbsolute = resolvedHref.startsWith(origin);\n  const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  }\n  // handle resolving href for dynamic routes\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n  const nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n  };\n  const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  const matchedPath = response.headers.get(\"x-matched-path\");\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {\n      const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig,\n        parseData: true\n      });\n      let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(param => {\n        let [pages, {\n          __rewrites: rewrites\n        }] = param;\n        let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            nextConfig: process.env.__NEXT_HAS_REWRITES ? undefined : nextConfig,\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n        if (process.env.__NEXT_HAS_REWRITES) {\n          const result = (0, _resolverewrites.default)(as, pages, rewrites, parsedRewriteTarget.query, path => resolveDynamicRoute(path, pages), options.router.locales);\n          if (result.matchedPage) {\n            parsedRewriteTarget.pathname = result.parsedAs.pathname;\n            as = parsedRewriteTarget.pathname;\n            Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n          }\n        } else if (!pages.includes(fsPathname)) {\n          const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n        const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref\n        };\n      });\n    }\n    const src = (0, _parsepath.parsePath)(source);\n    const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n      ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n        nextConfig,\n        parseData: true\n      }),\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    });\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n  const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      const src = (0, _parsepath.parsePath)(redirectTarget);\n      const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n        ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n          nextConfig,\n          parseData: true\n        }),\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      });\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + pathname + src.query + src.hash,\n        newUrl: \"\" + pathname + src.query + src.hash\n      });\n    }\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\nfunction withMiddlewareEffects(_x2) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = _asyncToGenerator(function* (options) {\n    const matches = yield matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n      return null;\n    }\n    try {\n      const data = yield options.fetchData();\n      const effect = yield getMiddlewareData(data.dataHref, data.response, options);\n      return {\n        dataHref: data.dataHref,\n        json: data.json,\n        response: data.response,\n        text: data.text,\n        cacheKey: data.cacheKey,\n        effect\n      };\n    } catch (e) {\n      /**\n      * TODO: Revisit this in the future.\n      * For now we will not consider middleware data errors to be fatal.\n      * maybe we should revisit in the future.\n      */\n      return null;\n    }\n  });\n  return _withMiddlewareEffects.apply(this, arguments);\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== \"undefined\" && \"scrollRestoration\" in window.history && !!function () {\n  try {\n    let v = \"__next\";\n    // eslint-disable-next-line no-sequences\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(response => {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\nfunction fetchNextData(param) {\n  let {\n    dataHref,\n    inflightCache,\n    isPrefetch,\n    hasMiddleware,\n    isServerRender,\n    parseJSON,\n    persistCache,\n    isBackground,\n    unstable_skipClientCache\n  } = param;\n  const {\n    href: cacheKey\n  } = new URL(dataHref, window.location.href);\n  var _params_method;\n  const getData = params => fetchRetry(dataHref, isServerRender ? 3 : 1, {\n    headers: Object.assign({}, isPrefetch ? {\n      purpose: \"prefetch\"\n    } : {}, isPrefetch && hasMiddleware ? {\n      \"x-middleware-prefetch\": \"1\"\n    } : {}),\n    method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n  }).then(response => {\n    if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n      return {\n        dataHref,\n        response,\n        text: \"\",\n        json: {},\n        cacheKey\n      };\n    }\n    return response.text().then(text => {\n      if (!response.ok) {\n        /**\n        * When the data response is a redirect because of a middleware\n        * we do not consider it an error. The headers must bring the\n        * mapped location.\n        * TODO: Change the status code in the handler.\n        */\n        if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n          return {\n            dataHref,\n            response,\n            text,\n            json: {},\n            cacheKey\n          };\n        }\n        if (response.status === 404) {\n          var _tryToParseAsJSON;\n          if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n            return {\n              dataHref,\n              json: {\n                notFound: SSG_DATA_NOT_FOUND\n              },\n              response,\n              text,\n              cacheKey\n            };\n          }\n        }\n        const error = new Error(\"Failed to load static props\");\n        /**\n        * We should only trigger a server-side transition if this was\n        * caused on a client-side transition. Otherwise, we'd get into\n        * an infinite loop.\n        */\n        if (!isServerRender) {\n          (0, _routeloader.markAssetError)(error);\n        }\n        throw error;\n      }\n      return {\n        dataHref,\n        json: parseJSON ? tryToParseAsJSON(text) : null,\n        response,\n        text,\n        cacheKey\n      };\n    });\n  }).then(data => {\n    if (!persistCache || process.env.NODE_ENV !== \"production\" || data.response.headers.get(\"x-middleware-cache\") === \"no-cache\") {\n      delete inflightCache[cacheKey];\n    }\n    return data;\n  }).catch(err => {\n    if (!unstable_skipClientCache) {\n      delete inflightCache[cacheKey];\n    }\n    if (\n    // chrome\n    err.message === \"Failed to fetch\" ||\n    // firefox\n    err.message === \"NetworkError when attempting to fetch resource.\" ||\n    // safari\n    err.message === \"Load failed\") {\n      (0, _routeloader.markAssetError)(err);\n    }\n    throw err;\n  });\n  // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(data => {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\nfunction createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n  let {\n    url,\n    router\n  } = param;\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n  window.location.href = url;\n}\nconst getCancelledHandler = param => {\n  let {\n    route,\n    router\n  } = param;\n  let cancelled = false;\n  const cancel = router.clc = () => {\n    cancelled = true;\n  };\n  const handleCancelled = () => {\n    if (cancelled) {\n      const error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n  return handleCancelled;\n};\nclass Router {\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n  back() {\n    window.history.back();\n  }\n  /**\n  * Go forward in history\n  */\n  forward() {\n    window.history.forward();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  push(url, as, options) {\n    if (options === void 0) options = {};\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n            x: self.pageXOffset,\n            y: self.pageYOffset\n          }));\n        } catch (e) {}\n      }\n    }\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change(\"pushState\", url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n  replace(url, as, options) {\n    if (options === void 0) options = {};\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change(\"replaceState\", url, as, options);\n  }\n  _bfl(as, resolvedAs, locale, skipNavigate) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n        let matchesBflStatic = false;\n        let matchesBflDynamic = false;\n        for (const curAs of [as, resolvedAs]) {\n          if (curAs) {\n            const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n            const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || _this.locale));\n            if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(_this.asPath, \"http://n\").pathname)) {\n              var _this__bfl_s, _this__bfl_s1;\n              matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = _this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = _this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n              for (const normalizedAS of [asNoSlash, asNoSlashLocale]) {\n                // if any sub-path of as matches a dynamic filter path\n                // it should be hard navigated\n                const curAsParts = normalizedAS.split(\"/\");\n                for (let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++) {\n                  var _this__bfl_d;\n                  const currentPart = curAsParts.slice(0, i).join(\"/\");\n                  if (currentPart && ((_this__bfl_d = _this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                    matchesBflDynamic = true;\n                    break;\n                  }\n                }\n              }\n              // if the client router filter is matched then we trigger\n              // a hard navigation\n              if (matchesBflStatic || matchesBflDynamic) {\n                if (skipNavigate) {\n                  return true;\n                }\n                handleHardNavigation({\n                  url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || _this.locale, _this.defaultLocale)),\n                  router: _this\n                });\n                return new Promise(() => {});\n              }\n            }\n          }\n        }\n      }\n      return false;\n    })();\n  }\n  change(method, url, as, options, forcedScroll) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _this_components_pathname;\n      if (!(0, _islocalurl.isLocalURL)(url)) {\n        handleHardNavigation({\n          url,\n          router: _this2\n        });\n        return false;\n      }\n      // WARNING: `_h` is an internal option for handing Next.js client-side\n      // hydration. Your app should _never_ use this property. It may change at\n      // any time without notice.\n      const isQueryUpdating = options._h === 1;\n      if (!isQueryUpdating && !options.shallow) {\n        yield _this2._bfl(as, undefined, options.locale);\n      }\n      let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n      const nextState = {\n        ..._this2.state\n      };\n      // for static pages with query params in the URL we delay\n      // marking the router ready until after the query is updated\n      // or a navigation has occurred\n      const readyStateChange = _this2.isReady !== true;\n      _this2.isReady = true;\n      const isSsr = _this2.isSsr;\n      if (!isQueryUpdating) {\n        _this2.isSsr = false;\n      }\n      // if a route transition is already in progress before\n      // the query updating is triggered ignore query updating\n      if (isQueryUpdating && _this2.clc) {\n        return false;\n      }\n      const prevLocale = nextState.locale;\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        nextState.locale = options.locale === false ? _this2.defaultLocale : options.locale || nextState.locale;\n        if (typeof options.locale === \"undefined\") {\n          options.locale = nextState.locale;\n        }\n        const parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n        const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, _this2.locales);\n        if (localePathResult.detectedLocale) {\n          nextState.locale = localePathResult.detectedLocale;\n          parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n          as = (0, _formaturl.formatWithValidation)(parsedAs);\n          url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, _this2.locales).pathname);\n        }\n        let didNavigate = false;\n        // we need to wrap this in the env check again since regenerator runtime\n        // moves this on its own due to the return\n        if (process.env.__NEXT_I18N_SUPPORT) {\n          var _this_locales;\n          // if the locale isn't configured hard navigate to show 404 page\n          if (!((_this_locales = _this2.locales) == null ? void 0 : _this_locales.includes(nextState.locale))) {\n            parsedAs.pathname = (0, _addlocale.addLocale)(parsedAs.pathname, nextState.locale);\n            handleHardNavigation({\n              url: (0, _formaturl.formatWithValidation)(parsedAs),\n              router: _this2\n            });\n            // this was previously a return but was removed in favor\n            // of better dead code elimination with regenerator runtime\n            didNavigate = true;\n          }\n        }\n        const detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(_this2.domainLocales, undefined, nextState.locale);\n        // we need to wrap this in the env check again since regenerator runtime\n        // moves this on its own due to the return\n        if (process.env.__NEXT_I18N_SUPPORT) {\n          // if we are navigating to a domain locale ensure we redirect to the\n          // correct domain\n          if (!didNavigate && detectedDomain && _this2.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n            const asNoBasePath = (0, _removebasepath.removeBasePath)(as);\n            handleHardNavigation({\n              url: \"http\" + (detectedDomain.http ? \"\" : \"s\") + \"://\" + detectedDomain.domain + (0, _addbasepath.addBasePath)(\"\" + (nextState.locale === detectedDomain.defaultLocale ? \"\" : \"/\" + nextState.locale) + (asNoBasePath === \"/\" ? \"\" : asNoBasePath) || \"/\"),\n              router: _this2\n            });\n            // this was previously a return but was removed in favor\n            // of better dead code elimination with regenerator runtime\n            didNavigate = true;\n          }\n        }\n        if (didNavigate) {\n          return new Promise(() => {});\n        }\n      }\n      // marking route changes as a navigation start entry\n      if (_utils.ST) {\n        performance.mark(\"routeChange\");\n      }\n      const {\n        shallow = false,\n        scroll = true\n      } = options;\n      const routeProps = {\n        shallow\n      };\n      if (_this2._inFlightRoute && _this2.clc) {\n        if (!isSsr) {\n          Router.events.emit(\"routeChangeError\", buildCancellationError(), _this2._inFlightRoute, routeProps);\n        }\n        _this2.clc();\n        _this2.clc = null;\n      }\n      as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, _this2.defaultLocale));\n      const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n      _this2._inFlightRoute = as;\n      const localeChange = prevLocale !== nextState.locale;\n      // If the url change is only related to a hash change\n      // We should not proceed. We should only change the state.\n      if (!isQueryUpdating && _this2.onlyAHashChange(cleanedAs) && !localeChange) {\n        nextState.asPath = cleanedAs;\n        Router.events.emit(\"hashChangeStart\", as, routeProps);\n        // TODO: do we need the resolved href when only a hash change?\n        _this2.changeState(method, url, as, {\n          ...options,\n          scroll: false\n        });\n        if (scroll) {\n          _this2.scrollToHash(cleanedAs);\n        }\n        try {\n          yield _this2.set(nextState, _this2.components[nextState.route], null);\n        } catch (err) {\n          if ((0, _iserror.default)(err) && err.cancelled) {\n            Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n          }\n          throw err;\n        }\n        Router.events.emit(\"hashChangeComplete\", as, routeProps);\n        return true;\n      }\n      let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n      let {\n        pathname,\n        query\n      } = parsed;\n      // if we detected the path as app route during prefetching\n      // trigger hard navigation\n      if ((_this_components_pathname = _this2.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n        handleHardNavigation({\n          url: as,\n          router: _this2\n        });\n        return new Promise(() => {});\n      }\n      // The build manifest needs to be loaded before auto-static dynamic pages\n      // get their query parameters to allow ensuring they can be parsed properly\n      // when rewritten to\n      let pages, rewrites;\n      try {\n        [pages, {\n          __rewrites: rewrites\n        }] = yield Promise.all([_this2.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), _this2.pageLoader.getMiddleware()]);\n      } catch (err) {\n        // If we fail to resolve the page list or client-build manifest, we must\n        // do a server-side transition:\n        handleHardNavigation({\n          url: as,\n          router: _this2\n        });\n        return false;\n      }\n      // If asked to change the current URL we should reload the current page\n      // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n      // We also need to set the method = replaceState always\n      // as this should not go into the history (That's how browsers work)\n      // We should compare the new asPath to the current asPath, not the url\n      if (!_this2.urlIsNew(cleanedAs) && !localeChange) {\n        method = \"replaceState\";\n      }\n      // we need to resolve the as value using rewrites for dynamic SSG\n      // pages to allow building the data URL correctly\n      let resolvedAs = as;\n      // url and as should always be prefixed with basePath by this\n      // point by either next/link or router.push/replace so strip the\n      // basePath from the pathname to match the pages dir 1-to-1\n      pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n      let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n      const parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n      const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n      // we don't attempt resolve asPath when we need to execute\n      // middleware as the resolving will occur server-side\n      const isMiddlewareMatch = !options.shallow && (yield matchesMiddleware({\n        asPath: as,\n        locale: nextState.locale,\n        router: _this2\n      }));\n      if (isQueryUpdating && isMiddlewareMatch) {\n        shouldResolveHref = false;\n      }\n      if (shouldResolveHref && pathname !== \"/_error\") {\n        options._shouldResolveHref = true;\n        if (process.env.__NEXT_HAS_REWRITES && as.startsWith(\"/\")) {\n          const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, p => resolveDynamicRoute(p, pages), _this2.locales);\n          if (rewritesResult.externalDest) {\n            handleHardNavigation({\n              url: as,\n              router: _this2\n            });\n            return true;\n          }\n          if (!isMiddlewareMatch) {\n            resolvedAs = rewritesResult.asPath;\n          }\n          if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n            // if this directly matches a page we need to update the href to\n            // allow the correct page chunk to be loaded\n            pathname = rewritesResult.resolvedHref;\n            parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n            if (!isMiddlewareMatch) {\n              url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n          }\n        } else {\n          parsed.pathname = resolveDynamicRoute(pathname, pages);\n          if (parsed.pathname !== pathname) {\n            pathname = parsed.pathname;\n            parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n            if (!isMiddlewareMatch) {\n              url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n          }\n        }\n      }\n      if (!(0, _islocalurl.isLocalURL)(as)) {\n        if (process.env.NODE_ENV !== \"production\") {\n          throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n        }\n        handleHardNavigation({\n          url: as,\n          router: _this2\n        });\n        return false;\n      }\n      resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n      route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n      let routeMatch = false;\n      if ((0, _isdynamic.isDynamicRoute)(route)) {\n        const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n        const asPathname = parsedAs.pathname;\n        const routeRegex = (0, _routeregex.getRouteRegex)(route);\n        routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n        const shouldInterpolate = route === asPathname;\n        const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n        if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n          const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param] && !routeRegex.groups[param].optional);\n          if (missingParams.length > 0 && !isMiddlewareMatch) {\n            if (process.env.NODE_ENV !== \"production\") {\n              console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n            }\n            throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n          }\n        } else if (shouldInterpolate) {\n          as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n            pathname: interpolatedAs.result,\n            query: (0, _omit.omit)(query, interpolatedAs.params)\n          }));\n        } else {\n          // Merge params into `query`, overwriting any specified in search\n          Object.assign(query, routeMatch);\n        }\n      }\n      if (!isQueryUpdating) {\n        Router.events.emit(\"routeChangeStart\", as, routeProps);\n      }\n      const isErrorRoute = _this2.pathname === \"/404\" || _this2.pathname === \"/_error\";\n      try {\n        var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n        let routeInfo = yield _this2.getRouteInfo({\n          route,\n          pathname,\n          query,\n          as,\n          resolvedAs,\n          routeProps,\n          locale: nextState.locale,\n          isPreview: nextState.isPreview,\n          hasMiddleware: isMiddlewareMatch,\n          unstable_skipClientCache: options.unstable_skipClientCache,\n          isQueryUpdating: isQueryUpdating && !_this2.isFallback,\n          isMiddlewareRewrite\n        });\n        if (!isQueryUpdating && !options.shallow) {\n          yield _this2._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n        }\n        if (\"route\" in routeInfo && isMiddlewareMatch) {\n          pathname = routeInfo.route || route;\n          route = pathname;\n          if (!routeProps.shallow) {\n            query = Object.assign({}, routeInfo.query || {}, query);\n          }\n          const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n          if (routeMatch && pathname !== cleanedParsedPathname) {\n            Object.keys(routeMatch).forEach(key => {\n              if (routeMatch && query[key] === routeMatch[key]) {\n                delete query[key];\n              }\n            });\n          }\n          if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n            const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n            let rewriteAs = prefixedAs;\n            if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n              rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n            }\n            if (process.env.__NEXT_I18N_SUPPORT) {\n              const localeResult = (0, _normalizelocalepath.normalizeLocalePath)(rewriteAs, _this2.locales);\n              nextState.locale = localeResult.detectedLocale || nextState.locale;\n              rewriteAs = localeResult.pathname;\n            }\n            const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n            const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n            if (curRouteMatch) {\n              Object.assign(query, curRouteMatch);\n            }\n          }\n        }\n        // If the routeInfo brings a redirect we simply apply it.\n        if (\"type\" in routeInfo) {\n          if (routeInfo.type === \"redirect-internal\") {\n            return _this2.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n          } else {\n            handleHardNavigation({\n              url: routeInfo.destination,\n              router: _this2\n            });\n            return new Promise(() => {});\n          }\n        }\n        const component = routeInfo.Component;\n        if (component && component.unstable_scriptLoader) {\n          const scripts = [].concat(component.unstable_scriptLoader());\n          scripts.forEach(script => {\n            (0, _script.handleClientScriptLoad)(script.props);\n          });\n        }\n        // handle redirect on client-transition\n        if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n          if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n            // Use the destination from redirect without adding locale\n            options.locale = false;\n            const destination = routeInfo.props.pageProps.__N_REDIRECT;\n            // check if destination is internal (resolves to a page) and attempt\n            // client-navigation if it is falling back to hard navigation if\n            // it's not\n            if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n              const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n              parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n              const {\n                url: newUrl,\n                as: newAs\n              } = prepareUrlAs(_this2, destination, destination);\n              return _this2.change(method, newUrl, newAs, options);\n            }\n            handleHardNavigation({\n              url: destination,\n              router: _this2\n            });\n            return new Promise(() => {});\n          }\n          nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n          // handle SSG data 404\n          if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n            let notFoundRoute;\n            try {\n              yield _this2.fetchComponent(\"/404\");\n              notFoundRoute = \"/404\";\n            } catch (_) {\n              notFoundRoute = \"/_error\";\n            }\n            routeInfo = yield _this2.getRouteInfo({\n              route: notFoundRoute,\n              pathname: notFoundRoute,\n              query,\n              as,\n              resolvedAs,\n              routeProps: {\n                shallow: false\n              },\n              locale: nextState.locale,\n              isPreview: nextState.isPreview,\n              isNotFound: true\n            });\n            if (\"type\" in routeInfo) {\n              throw new Error(\"Unexpected middleware effect on /404\");\n            }\n          }\n        }\n        if (isQueryUpdating && _this2.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n          // ensure statusCode is still correct for static 500 page\n          // when updating query information\n          routeInfo.props.pageProps.statusCode = 500;\n        }\n        var _routeInfo_route;\n        // shallow routing is only allowed for same page URL changes.\n        const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n        var _options_scroll;\n        const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n        const resetScroll = shouldScroll ? {\n          x: 0,\n          y: 0\n        } : null;\n        const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n        // the new state that the router gonna set\n        const upcomingRouterState = {\n          ...nextState,\n          route,\n          pathname,\n          query,\n          asPath: cleanedAs,\n          isFallback: false\n        };\n        // When the page being rendered is the 404 page, we should only update the\n        // query parameters. Route changes here might add the basePath when it\n        // wasn't originally present. This is also why this block is before the\n        // below `changeState` call which updates the browser's history (changing\n        // the URL).\n        if (isQueryUpdating && isErrorRoute) {\n          var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n          routeInfo = yield _this2.getRouteInfo({\n            route: _this2.pathname,\n            pathname: _this2.pathname,\n            query,\n            as,\n            resolvedAs,\n            routeProps: {\n              shallow: false\n            },\n            locale: nextState.locale,\n            isPreview: nextState.isPreview,\n            isQueryUpdating: isQueryUpdating && !_this2.isFallback\n          });\n          if (\"type\" in routeInfo) {\n            throw new Error(\"Unexpected middleware effect on \" + _this2.pathname);\n          }\n          if (_this2.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n            // ensure statusCode is still correct for static 500 page\n            // when updating query information\n            routeInfo.props.pageProps.statusCode = 500;\n          }\n          try {\n            yield _this2.set(upcomingRouterState, routeInfo, upcomingScrollState);\n          } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n              Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n            }\n            throw err;\n          }\n          return true;\n        }\n        Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n        _this2.changeState(method, url, as, options);\n        // for query updates we can skip it if the state is unchanged and we don't\n        // need to scroll\n        // https://github.com/vercel/next.js/issues/37139\n        const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, _this2.state);\n        if (!canSkipUpdating) {\n          try {\n            yield _this2.set(upcomingRouterState, routeInfo, upcomingScrollState);\n          } catch (e) {\n            if (e.cancelled) routeInfo.error = routeInfo.error || e;else throw e;\n          }\n          if (routeInfo.error) {\n            if (!isQueryUpdating) {\n              Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n            }\n            throw routeInfo.error;\n          }\n          if (process.env.__NEXT_I18N_SUPPORT) {\n            if (nextState.locale) {\n              document.documentElement.lang = nextState.locale;\n            }\n          }\n          if (!isQueryUpdating) {\n            Router.events.emit(\"routeChangeComplete\", as, routeProps);\n          }\n          // A hash mark # is the optional last part of a URL\n          const hashRegex = /#.+$/;\n          if (shouldScroll && hashRegex.test(as)) {\n            _this2.scrollToHash(as);\n          }\n        }\n        return true;\n      } catch (err) {\n        if ((0, _iserror.default)(err) && err.cancelled) {\n          return false;\n        }\n        throw err;\n      }\n    })();\n  }\n  changeState(method, url, as, options) {\n    if (options === void 0) options = {};\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof window.history === \"undefined\") {\n        console.error(\"Warning: window.history is not available.\");\n        return;\n      }\n      if (typeof window.history[method] === \"undefined\") {\n        console.error(\"Warning: window.history.\" + method + \" is not available\");\n        return;\n      }\n    }\n    if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        key: this._key = method !== \"pushState\" ? this._key : createKey()\n      },\n      // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/docs/Web/API/History/replaceState\n      \"\", as);\n    }\n  }\n  handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      console.error(err);\n      if (err.cancelled) {\n        // bubble up cancellation errors\n        throw err;\n      }\n      if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n        Router.events.emit(\"routeChangeError\", err, as, routeProps);\n        // If we can't load the page it could be one of following reasons\n        //  1. Page doesn't exists\n        //  2. Page does exist in a different zone\n        //  3. Internal error while loading the page\n        // So, doing a hard reload is the proper way to deal with this.\n        handleHardNavigation({\n          url: as,\n          router: _this3\n        });\n        // Changing the URL doesn't block executing the current code path.\n        // So let's throw a cancellation error stop the routing logic.\n        throw buildCancellationError();\n      }\n      try {\n        let props;\n        const {\n          page: Component,\n          styleSheets\n        } = yield _this3.fetchComponent(\"/_error\");\n        const routeInfo = {\n          props,\n          Component,\n          styleSheets,\n          err,\n          error: err\n        };\n        if (!routeInfo.props) {\n          try {\n            routeInfo.props = yield _this3.getInitialProps(Component, {\n              err,\n              pathname,\n              query\n            });\n          } catch (gipErr) {\n            console.error(\"Error in error page `getInitialProps`: \", gipErr);\n            routeInfo.props = {};\n          }\n        }\n        return routeInfo;\n      } catch (routeInfoErr) {\n        return _this3.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n      }\n    })();\n  }\n  getRouteInfo(param) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let {\n        route: requestedRoute,\n        pathname,\n        query,\n        as,\n        resolvedAs,\n        routeProps,\n        locale,\n        hasMiddleware,\n        isPreview,\n        unstable_skipClientCache,\n        isQueryUpdating,\n        isMiddlewareRewrite,\n        isNotFound\n      } = param;\n      /**\n      * This `route` binding can change if there's a rewrite\n      * so we keep a reference to the original requested route\n      * so we can store the cache for it and avoid re-requesting every time\n      * for shallow routing purposes.\n      */\n      let route = requestedRoute;\n      try {\n        var _data_effect, _data_effect1, _data_effect2, _data_response;\n        const handleCancelled = getCancelledHandler({\n          route,\n          router: _this4\n        });\n        let existingInfo = _this4.components[route];\n        if (routeProps.shallow && existingInfo && _this4.route === route) {\n          return existingInfo;\n        }\n        if (hasMiddleware) {\n          existingInfo = undefined;\n        }\n        let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && process.env.NODE_ENV !== \"development\" ? existingInfo : undefined;\n        const isBackground = isQueryUpdating;\n        const fetchNextDataParams = {\n          dataHref: _this4.pageLoader.getDataHref({\n            href: (0, _formaturl.formatWithValidation)({\n              pathname,\n              query\n            }),\n            skipInterpolation: true,\n            asPath: isNotFound ? \"/404\" : resolvedAs,\n            locale\n          }),\n          hasMiddleware: true,\n          isServerRender: _this4.isSsr,\n          parseJSON: true,\n          inflightCache: isBackground ? _this4.sbc : _this4.sdc,\n          persistCache: !isPreview,\n          isPrefetch: false,\n          unstable_skipClientCache,\n          isBackground\n        };\n        let data = isQueryUpdating && !isMiddlewareRewrite ? null : yield withMiddlewareEffects({\n          fetchData: () => fetchNextData(fetchNextDataParams),\n          asPath: isNotFound ? \"/404\" : resolvedAs,\n          locale: locale,\n          router: _this4\n        }).catch(err => {\n          // we don't hard error during query updating\n          // as it's un-necessary and doesn't need to be fatal\n          // unless it is a fallback route and the props can't\n          // be loaded\n          if (isQueryUpdating) {\n            return null;\n          }\n          throw err;\n        });\n        // when rendering error routes we don't apply middleware\n        // effects\n        if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n          data.effect = undefined;\n        }\n        if (isQueryUpdating) {\n          if (!data) {\n            data = {\n              json: self.__NEXT_DATA__.props\n            };\n          } else {\n            data.json = self.__NEXT_DATA__.props;\n          }\n        }\n        handleCancelled();\n        if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n          return data.effect;\n        }\n        if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\") {\n          const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n          const pages = yield _this4.pageLoader.getPageList();\n          // during query updating the page must match although during\n          // client-transition a redirect that doesn't match a page\n          // can be returned and this should trigger a hard navigation\n          // which is valid for incremental migration\n          if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n            route = resolvedRoute;\n            pathname = data.effect.resolvedHref;\n            query = {\n              ...query,\n              ...data.effect.parsedAs.query\n            };\n            resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, _this4.locales).pathname);\n            // Check again the cache with the new destination.\n            existingInfo = _this4.components[route];\n            if (routeProps.shallow && existingInfo && _this4.route === route && !hasMiddleware) {\n              // If we have a match with the current route due to rewrite,\n              // we can copy the existing information to the rewritten one.\n              // Then, we return the information along with the matched route.\n              return {\n                ...existingInfo,\n                route\n              };\n            }\n          }\n        }\n        if ((0, _isapiroute.isAPIRoute)(route)) {\n          handleHardNavigation({\n            url: as,\n            router: _this4\n          });\n          return new Promise(() => {});\n        }\n        const routeInfo = cachedRouteInfo || (yield _this4.fetchComponent(route).then(res => ({\n          Component: res.page,\n          styleSheets: res.styleSheets,\n          __N_SSG: res.mod.__N_SSG,\n          __N_SSP: res.mod.__N_SSP\n        })));\n        if (process.env.NODE_ENV !== \"production\") {\n          const {\n            isValidElementType\n          } = require(\"next/dist/compiled/react-is\");\n          if (!isValidElementType(routeInfo.Component)) {\n            throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n          }\n        }\n        const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n        const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n        // For non-SSG prefetches that bailed before sending data\n        // we clear the cache to fetch full response\n        if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n          delete _this4.sdc[data.dataHref];\n        }\n        const {\n          props,\n          cacheKey\n        } = yield _this4._getData( /*#__PURE__*/_asyncToGenerator(function* () {\n          if (shouldFetchData) {\n            if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n              return {\n                cacheKey: data.cacheKey,\n                props: data.json\n              };\n            }\n            const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this4.pageLoader.getDataHref({\n              href: (0, _formaturl.formatWithValidation)({\n                pathname,\n                query\n              }),\n              asPath: resolvedAs,\n              locale\n            });\n            const fetched = yield fetchNextData({\n              dataHref,\n              isServerRender: _this4.isSsr,\n              parseJSON: true,\n              inflightCache: wasBailedPrefetch ? {} : _this4.sdc,\n              persistCache: !isPreview,\n              isPrefetch: false,\n              unstable_skipClientCache\n            });\n            return {\n              cacheKey: fetched.cacheKey,\n              props: fetched.json || {}\n            };\n          }\n          return {\n            headers: {},\n            props: yield _this4.getInitialProps(routeInfo.Component,\n            // we provide AppTree later so this needs to be `any`\n            {\n              pathname,\n              query,\n              asPath: as,\n              locale,\n              locales: _this4.locales,\n              defaultLocale: _this4.defaultLocale\n            })\n          };\n        }));\n        // Only bust the data cache for SSP routes although\n        // middleware can skip cache per request with\n        // x-middleware-cache: no-cache as well\n        if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n          delete _this4.sdc[cacheKey];\n        }\n        // we kick off a HEAD request in the background\n        // when a non-prefetch request is made to signal revalidation\n        if (!_this4.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== \"development\" && !isQueryUpdating) {\n          fetchNextData(Object.assign({}, fetchNextDataParams, {\n            isBackground: true,\n            persistCache: false,\n            inflightCache: _this4.sbc\n          })).catch(() => {});\n        }\n        props.pageProps = Object.assign({}, props.pageProps);\n        routeInfo.props = props;\n        routeInfo.route = route;\n        routeInfo.query = query;\n        routeInfo.resolvedAs = resolvedAs;\n        _this4.components[route] = routeInfo;\n        return routeInfo;\n      } catch (err) {\n        return _this4.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n      }\n    })();\n  }\n  set(state, data, resetScroll) {\n    this.state = state;\n    return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\");\n    const [newUrlNoHash, newHash] = as.split(\"#\");\n    // Makes sure we scroll to the provided hash if the url/hash are the same\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    }\n    // If the urls are change, there's more than a hash change\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    }\n    // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n    return oldHash !== newHash;\n  }\n  scrollToHash(as) {\n    const [, hash = \"\"] = as.split(\"#\");\n    (0, _handlesmoothscroll.handleSmoothScroll)(() => {\n      // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n      if (hash === \"\" || hash === \"top\") {\n        window.scrollTo(0, 0);\n        return;\n      }\n      // Decode hash to make non-latin anchor works.\n      const rawHash = decodeURIComponent(hash);\n      // First we check if the element by id is found\n      const idEl = document.getElementById(rawHash);\n      if (idEl) {\n        idEl.scrollIntoView();\n        return;\n      }\n      // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n      const nameEl = document.getElementsByName(rawHash)[0];\n      if (nameEl) {\n        nameEl.scrollIntoView();\n      }\n    }, {\n      onlyHashChange: this.onlyAHashChange(as)\n    });\n  }\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n  prefetch(url, asPath, options) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (asPath === void 0) asPath = url;\n      if (options === void 0) options = {};\n      // Prefetch is not supported in development mode because it would trigger on-demand-entries\n      if (process.env.NODE_ENV !== \"production\") {\n        return;\n      }\n      if (typeof window !== \"undefined\" && (0, _isbot.isBot)(window.navigator.userAgent)) {\n        // No prefetches for bots that render the link since they are typically navigating\n        // links via the equivalent of a hard navigation and hence never utilize these\n        // prefetches.\n        return;\n      }\n      let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n      const urlPathname = parsed.pathname;\n      let {\n        pathname,\n        query\n      } = parsed;\n      const originalPathname = pathname;\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        if (options.locale === false) {\n          pathname = (0, _normalizelocalepath.normalizeLocalePath)(pathname, _this5.locales).pathname;\n          parsed.pathname = pathname;\n          url = (0, _formaturl.formatWithValidation)(parsed);\n          let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n          const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, _this5.locales);\n          parsedAs.pathname = localePathResult.pathname;\n          options.locale = localePathResult.detectedLocale || _this5.defaultLocale;\n          asPath = (0, _formaturl.formatWithValidation)(parsedAs);\n        }\n      }\n      const pages = yield _this5.pageLoader.getPageList();\n      let resolvedAs = asPath;\n      const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this5.locale;\n      const isMiddlewareMatch = yield matchesMiddleware({\n        asPath: asPath,\n        locale: locale,\n        router: _this5\n      });\n      if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith(\"/\")) {\n        let rewrites;\n        ({\n          __rewrites: rewrites\n        } = yield (0, _routeloader.getClientBuildManifest)());\n        const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, _this5.locale), true), pages, rewrites, parsed.query, p => resolveDynamicRoute(p, pages), _this5.locales);\n        if (rewritesResult.externalDest) {\n          return;\n        }\n        if (!isMiddlewareMatch) {\n          resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), _this5.locale);\n        }\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref;\n          parsed.pathname = pathname;\n          if (!isMiddlewareMatch) {\n            url = (0, _formaturl.formatWithValidation)(parsed);\n          }\n        }\n      }\n      parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n      if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n        pathname = parsed.pathname;\n        parsed.pathname = pathname;\n        Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n        if (!isMiddlewareMatch) {\n          url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n      }\n      const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === \"strict\" ? null : yield withMiddlewareEffects({\n        fetchData: () => fetchNextData({\n          dataHref: _this5.pageLoader.getDataHref({\n            href: (0, _formaturl.formatWithValidation)({\n              pathname: originalPathname,\n              query\n            }),\n            skipInterpolation: true,\n            asPath: resolvedAs,\n            locale\n          }),\n          hasMiddleware: true,\n          isServerRender: _this5.isSsr,\n          parseJSON: true,\n          inflightCache: _this5.sdc,\n          persistCache: !_this5.isPreview,\n          isPrefetch: true\n        }),\n        asPath: asPath,\n        locale: locale,\n        router: _this5\n      });\n      /**\n      * If there was a rewrite we apply the effects of the rewrite on the\n      * current parameters for the prefetch.\n      */\n      if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n        parsed.pathname = data.effect.resolvedHref;\n        pathname = data.effect.resolvedHref;\n        query = {\n          ...query,\n          ...data.effect.parsedAs.query\n        };\n        resolvedAs = data.effect.parsedAs.pathname;\n        url = (0, _formaturl.formatWithValidation)(parsed);\n      }\n      /**\n      * If there is a redirect to an external destination then we don't have\n      * to prefetch content as it will be unused.\n      */\n      if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n        return;\n      }\n      const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n      if (yield _this5._bfl(asPath, resolvedAs, options.locale, true)) {\n        _this5.components[urlPathname] = {\n          __appRouter: true\n        };\n      }\n      yield Promise.all([_this5.pageLoader._isSsg(route).then(isSsg => {\n        return isSsg ? fetchNextData({\n          dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this5.pageLoader.getDataHref({\n            href: url,\n            asPath: resolvedAs,\n            locale: locale\n          }),\n          isServerRender: false,\n          parseJSON: true,\n          inflightCache: _this5.sdc,\n          persistCache: !_this5.isPreview,\n          isPrefetch: true,\n          unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n        }).then(() => false).catch(() => false) : false;\n      }), _this5.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n    })();\n  }\n  fetchComponent(route) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const handleCancelled = getCancelledHandler({\n        route,\n        router: _this6\n      });\n      try {\n        const componentResult = yield _this6.pageLoader.loadPage(route);\n        handleCancelled();\n        return componentResult;\n      } catch (err) {\n        handleCancelled();\n        throw err;\n      }\n    })();\n  }\n  _getData(fn) {\n    let cancelled = false;\n    const cancel = () => {\n      cancelled = true;\n    };\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n      if (cancelled) {\n        const err = new Error(\"Loading initial props cancelled\");\n        err.cancelled = true;\n        throw err;\n      }\n      return data;\n    });\n  }\n  _getFlightData(dataHref) {\n    // Do not cache RSC flight response since it's not a static resource\n    return fetchNextData({\n      dataHref,\n      isServerRender: true,\n      parseJSON: false,\n      inflightCache: this.sdc,\n      persistCache: false,\n      isPrefetch: false\n    }).then(param => {\n      let {\n        text\n      } = param;\n      return {\n        data: text\n      };\n    });\n  }\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components[\"/_app\"];\n    const AppTree = this._wrapApp(App);\n    ctx.AppTree = AppTree;\n    return (0, _utils.loadGetInitialProps)(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n  get route() {\n    return this.state.route;\n  }\n  get pathname() {\n    return this.state.pathname;\n  }\n  get query() {\n    return this.state.query;\n  }\n  get asPath() {\n    return this.state.asPath;\n  }\n  get locale() {\n    return this.state.locale;\n  }\n  get isFallback() {\n    return this.state.isFallback;\n  }\n  get isPreview() {\n    return this.state.isPreview;\n  }\n  constructor(pathname, query, as, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale,\n    domainLocales,\n    isPreview\n  }) {\n    // Server Data Cache (full data requests)\n    this.sdc = {};\n    // Server Background Cache (HEAD requests)\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = createKey();\n    this.onPopState = e => {\n      const {\n        isFirstPopStateEvent\n      } = this;\n      this.isFirstPopStateEvent = false;\n      const state = e.state;\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(pathname),\n          query\n        }), (0, _utils.getURL)());\n        return;\n      }\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n      if (!state.__N) {\n        return;\n      }\n      // Safari fires popstateevent when reopening the browser.\n      if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n        return;\n      }\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        key\n      } = state;\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (this._key !== key) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch (e) {}\n            // Restore old scroll position:\n            try {\n              const v = sessionStorage.getItem(\"__next_scroll_\" + key);\n              forcedScroll = JSON.parse(v);\n            } catch (e) {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n      this._key = key;\n      const {\n        pathname\n      } = (0, _parserelativeurl.parseRelativeUrl)(url);\n      // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n      if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n        return;\n      }\n      // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n      this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    };\n    // represents the current component key\n    const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n    // set up the component cache (by route keys)\n    this.components = {};\n    // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n    if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n      const {\n        BloomFilter\n      } = require(\"../../lib/bloom-filter\");\n      const staticFilterData = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;\n      const dynamicFilterData = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;\n      if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n        this._bfl_s.import(staticFilterData);\n      }\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n        this._bfl_d.import(dynamicFilterData);\n      }\n    }\n    // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n    this.basePath = process.env.__NEXT_ROUTER_BASEPATH || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp;\n    // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!(0, _detectdomainlocale.detectDomainLocale)(domainLocales, self.location.hostname);\n    }\n    this.state = {\n      route,\n      pathname,\n      query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n    if (typeof window !== \"undefined\") {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options = {\n          locale\n        };\n        const asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale,\n          asPath\n        }).then(matches => {\n          options._shouldResolveHref = as !== pathname;\n          this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query\n          }), asPath, options);\n          return matches;\n        });\n      }\n      window.addEventListener(\"popstate\", this.onPopState);\n      // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = \"manual\";\n        }\n      }\n    }\n  }\n}\nRouter.events = (0, _mitt.default)();","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","module","matchesMiddleware","createKey","_export","target","all","name","enumerable","get","Router","_interop_require_default","_interop_require_wildcard","_removetrailingslash","_routeloader","_script","_iserror","_","_denormalizepagepath","_normalizelocalepath","_mitt","_utils","_isdynamic","_parserelativeurl","_resolverewrites","_routematcher","_routeregex","_formaturl","_detectdomainlocale","_parsepath","_addlocale","_removelocale","_removebasepath","_addbasepath","_hasbasepath","_resolvehref","_isapiroute","_getnextpathnameinfo","_formatnextpathnameinfo","_comparestates","_islocalurl","_isbot","_omit","_interpolateas","_handlesmoothscroll","buildCancellationError","assign","Error","cancelled","_x","_matchesMiddleware","apply","arguments","options","matchers","Promise","resolve","router","pageLoader","getMiddleware","pathname","asPathname","parsePath","asPath","cleanedAs","hasBasePath","removeBasePath","asWithBasePathAndLocale","addBasePath","addLocale","locale","some","m","RegExp","regexp","test","stripOrigin","url","origin","getLocationOrigin","startsWith","substring","length","prepareUrlAs","as","resolvedHref","resolvedAs","resolveHref","hrefWasAbsolute","asWasAbsolute","preparedUrl","preparedAs","resolveDynamicRoute","pages","cleanPathname","removeTrailingSlash","denormalizePagePath","includes","page","isDynamicRoute","getRouteRegex","re","getMiddlewareData","source","response","nextConfig","basePath","i18n","locales","trailingSlash","Boolean","process","env","__NEXT_TRAILING_SLASH","rewriteHeader","headers","rewriteTarget","matchedPath","__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE","parsedRewriteTarget","parseRelativeUrl","pathnameInfo","getNextPathnameInfo","parseData","fsPathname","getPageList","getClientBuildManifest","then","param","__rewrites","rewrites","normalizeLocalePath","parsedSource","__NEXT_HAS_REWRITES","undefined","result","query","path","matchedPage","parsedAs","resolvedPathname","matches","getRouteMatcher","type","src","formatNextPathnameInfo","defaultLocale","buildId","destination","hash","redirectTarget","newAs","newUrl","withMiddlewareEffects","_x2","_withMiddlewareEffects","fetchData","data","effect","dataHref","json","text","cacheKey","e","manualScrollRestoration","__NEXT_SCROLL_RESTORATION","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","fetchRetry","attempts","fetch","credentials","method","ok","status","tryToParseAsJSON","JSON","parse","error","fetchNextData","inflightCache","isPrefetch","hasMiddleware","isServerRender","parseJSON","persistCache","isBackground","unstable_skipClientCache","href","URL","location","_params_method","getData","params","purpose","_tryToParseAsJSON","notFound","markAssetError","NODE_ENV","catch","err","message","Math","random","toString","slice","handleHardNavigation","getCancelledHandler","route","cancel","clc","handleCancelled","reload","back","forward","push","_key","stringify","x","self","pageXOffset","y","pageYOffset","change","replace","_bfl","skipNavigate","_this","__NEXT_CLIENT_ROUTER_FILTER_ENABLED","matchesBflStatic","matchesBflDynamic","curAs","asNoSlash","asNoSlashLocale","_this__bfl_s","_this__bfl_s1","_bfl_s","contains","normalizedAS","curAsParts","split","i","_this__bfl_d","currentPart","join","_bfl_d","forcedScroll","_this2","_this_components_pathname","isLocalURL","isQueryUpdating","_h","shallow","shouldResolveHref","_shouldResolveHref","nextState","state","readyStateChange","isReady","isSsr","prevLocale","__NEXT_I18N_SUPPORT","localePathResult","detectedLocale","formatWithValidation","didNavigate","_this_locales","detectedDomain","detectDomainLocale","domainLocales","isLocaleDomain","hostname","domain","asNoBasePath","http","ST","performance","mark","scroll","routeProps","_inFlightRoute","events","emit","removeLocale","localeChange","onlyAHashChange","changeState","scrollToHash","set","components","parsed","__appRouter","urlIsNew","parsedAsPathname","isMiddlewareRewrite","isMiddlewareMatch","rewritesResult","p","externalDest","routeMatch","routeRegex","shouldInterpolate","interpolatedAs","interpolateAs","missingParams","keys","groups","filter","optional","console","warn","omit","isErrorRoute","_self___NEXT_DATA___props_pageProps","_self___NEXT_DATA___props","_routeInfo_props","routeInfo","getRouteInfo","isPreview","isFallback","cleanedParsedPathname","forEach","key","prefixedAs","rewriteAs","localeResult","curRouteMatch","component","Component","unstable_scriptLoader","scripts","concat","script","handleClientScriptLoad","props","__N_SSG","__N_SSP","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","parsedHref","__N_PREVIEW","notFoundRoute","fetchComponent","isNotFound","__NEXT_DATA__","statusCode","_routeInfo_route","isValidShallowRoute","_options_scroll","shouldScroll","resetScroll","upcomingScrollState","upcomingRouterState","_self___NEXT_DATA___props_pageProps1","_self___NEXT_DATA___props1","_routeInfo_props1","canSkipUpdating","compareRouterStates","document","documentElement","lang","hashRegex","getURL","_shallow","__N","handleRouteInfoError","loadErrorFail","_this3","isAssetError","styleSheets","getInitialProps","gipErr","routeInfoErr","_this4","requestedRoute","_data_effect","_data_effect1","_data_effect2","_data_response","existingInfo","cachedRouteInfo","fetchNextDataParams","getDataHref","skipInterpolation","sbc","sdc","resolvedRoute","isAPIRoute","res","mod","isValidElementType","wasBailedPrefetch","shouldFetchData","_getData","fetched","getProperError","sub","beforePopState","cb","_bps","oldUrlNoHash","oldHash","newUrlNoHash","newHash","handleSmoothScroll","scrollTo","rawHash","decodeURIComponent","idEl","getElementById","scrollIntoView","nameEl","getElementsByName","onlyHashChange","prefetch","_this5","isBot","navigator","userAgent","urlPathname","originalPathname","__NEXT_MIDDLEWARE_PREFETCH","_isSsg","isSsg","priority","__NEXT_OPTIMISTIC_CLIENT_CACHE","_this6","componentResult","loadPage","fn","_getFlightData","ctx","App","AppTree","_wrapApp","loadGetInitialProps","constructor","initialProps","wrapApp","subscription","isFirstPopStateEvent","onPopState","__NA","getItem","initial","BloomFilter","staticFilterData","__NEXT_CLIENT_ROUTER_S_FILTER","dynamicFilterData","__NEXT_CLIENT_ROUTER_D_FILTER","numHashes","numItems","errorRate","import","autoExportDynamic","autoExport","__NEXT_ROUTER_BASEPATH","gssp","gip","appGip","gsp","search","_initialMatchesMiddlewarePromise","addEventListener","scrollRestoration"],"sources":["C:/Users/BNI/node_modules/next/dist/shared/lib/router/router.js"],"sourcesContent":["// tslint:disable:no-console\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    matchesMiddleware: null,\n    createKey: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    },\n    createKey: function() {\n        return createKey;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _removetrailingslash = require(\"./utils/remove-trailing-slash\");\nconst _routeloader = require(\"../../../client/route-loader\");\nconst _script = require(\"../../../client/script\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(require(\"../../../lib/is-error\"));\nconst _denormalizepagepath = require(\"../page-path/denormalize-page-path\");\nconst _normalizelocalepath = require(\"../i18n/normalize-locale-path\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(require(\"../mitt\"));\nconst _utils = require(\"../utils\");\nconst _isdynamic = require(\"./utils/is-dynamic\");\nconst _parserelativeurl = require(\"./utils/parse-relative-url\");\nconst _resolverewrites = /*#__PURE__*/ _interop_require_default._(require(\"./utils/resolve-rewrites\"));\nconst _routematcher = require(\"./utils/route-matcher\");\nconst _routeregex = require(\"./utils/route-regex\");\nconst _formaturl = require(\"./utils/format-url\");\nconst _detectdomainlocale = require(\"../../../client/detect-domain-locale\");\nconst _parsepath = require(\"./utils/parse-path\");\nconst _addlocale = require(\"../../../client/add-locale\");\nconst _removelocale = require(\"../../../client/remove-locale\");\nconst _removebasepath = require(\"../../../client/remove-base-path\");\nconst _addbasepath = require(\"../../../client/add-base-path\");\nconst _hasbasepath = require(\"../../../client/has-base-path\");\nconst _resolvehref = require(\"../../../client/resolve-href\");\nconst _isapiroute = require(\"../../../lib/is-api-route\");\nconst _getnextpathnameinfo = require(\"./utils/get-next-pathname-info\");\nconst _formatnextpathnameinfo = require(\"./utils/format-next-pathname-info\");\nconst _comparestates = require(\"./utils/compare-states\");\nconst _islocalurl = require(\"./utils/is-local-url\");\nconst _isbot = require(\"./utils/is-bot\");\nconst _omit = require(\"./utils/omit\");\nconst _interpolateas = require(\"./utils/interpolate-as\");\nconst _handlesmoothscroll = require(\"./utils/handle-smooth-scroll\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)\n    };\n    const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    const matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then((param)=>{\n                let [pages, { __rewrites: rewrites }] = param;\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig: process.env.__NEXT_HAS_REWRITES ? undefined : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (process.env.__NEXT_HAS_REWRITES) {\n                    const result = (0, _resolverewrites.default)(as, pages, rewrites, parsedRewriteTarget.query, (path)=>resolveDynamicRoute(path, pages), options.router.locales);\n                    if (result.matchedPage) {\n                        parsedRewriteTarget.pathname = result.parsedAs.pathname;\n                        as = parsedRewriteTarget.pathname;\n                        Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n                    }\n                } else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        });\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            });\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname + src.query + src.hash,\n                newUrl: \"\" + pathname + src.query + src.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    try {\n        const data = await options.fetchData();\n        const effect = await getMiddlewareData(data.dataHref, data.response, options);\n        return {\n            dataHref: data.dataHref,\n            json: data.json,\n            response: data.response,\n            text: data.text,\n            cacheKey: data.cacheKey,\n            effect\n        };\n    } catch (e) {\n        /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return null;\n    }\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== \"undefined\" && \"scrollRestoration\" in window.history && !!function() {\n    try {\n        let v = \"__next\";\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    let { dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache } = param;\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    var _params_method;\n    const getData = (params)=>fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref,\n                    response,\n                    text: \"\",\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || process.env.NODE_ENV !== \"production\" || data.response.headers.get(\"x-middleware-cache\") === \"no-cache\") {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (// chrome\n            err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    let { url, router } = param;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = (param)=>{\n    let { route, router } = param;\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options) {\n        if (options === void 0) options = {};\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch (e) {}\n            }\n        }\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"pushState\", url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options) {\n        if (options === void 0) options = {};\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"replaceState\", url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            for (const curAs of [\n                as,\n                resolvedAs\n            ]){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname)) {\n                        var _this__bfl_s, _this__bfl_s1;\n                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split(\"/\");\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                var _this__bfl_d;\n                                const currentPart = curAsParts.slice(0, i).join(\"/\");\n                                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        var _this_components_pathname;\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n            if (typeof options.locale === \"undefined\") {\n                options.locale = nextState.locale;\n            }\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n            const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n            if (localePathResult.detectedLocale) {\n                nextState.locale = localePathResult.detectedLocale;\n                parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                as = (0, _formaturl.formatWithValidation)(parsedAs);\n                url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n            }\n            let didNavigate = false;\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                var _this_locales;\n                // if the locale isn't configured hard navigate to show 404 page\n                if (!((_this_locales = this.locales) == null ? void 0 : _this_locales.includes(nextState.locale))) {\n                    parsedAs.pathname = (0, _addlocale.addLocale)(parsedAs.pathname, nextState.locale);\n                    handleHardNavigation({\n                        url: (0, _formaturl.formatWithValidation)(parsedAs),\n                        router: this\n                    });\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            const detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale);\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                // if we are navigating to a domain locale ensure we redirect to the\n                // correct domain\n                if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                    const asNoBasePath = (0, _removebasepath.removeBasePath)(as);\n                    handleHardNavigation({\n                        url: \"http\" + (detectedDomain.http ? \"\" : \"s\") + \"://\" + detectedDomain.domain + (0, _addbasepath.addBasePath)(\"\" + (nextState.locale === detectedDomain.defaultLocale ? \"\" : \"/\" + nextState.locale) + (asNoBasePath === \"/\" ? \"\" : asNoBasePath) || \"/\"),\n                        router: this\n                    });\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            if (didNavigate) {\n                return new Promise(()=>{});\n            }\n        }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark(\"routeChange\");\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit(\"hashChangeStart\", as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit(\"hashChangeComplete\", as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = \"replaceState\";\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== \"/_error\") {\n            options._shouldResolveHref = true;\n            if (process.env.__NEXT_HAS_REWRITES && as.startsWith(\"/\")) {\n                const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages), this.locales);\n                if (rewritesResult.externalDest) {\n                    handleHardNavigation({\n                        url: as,\n                        router: this\n                    });\n                    return true;\n                }\n                if (!isMiddlewareMatch) {\n                    resolvedAs = rewritesResult.asPath;\n                }\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            } else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (process.env.NODE_ENV !== \"production\") {\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (process.env.NODE_ENV !== \"production\") {\n                        console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                    }\n                    throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit(\"routeChangeStart\", as, routeProps);\n        }\n        const isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n        try {\n            var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if (\"route\" in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (process.env.__NEXT_I18N_SUPPORT) {\n                        const localeResult = (0, _normalizelocalepath.normalizeLocalePath)(rewriteAs, this.locales);\n                        nextState.locale = localeResult.detectedLocale || nextState.locale;\n                        rewriteAs = localeResult.pathname;\n                    }\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if (\"type\" in routeInfo) {\n                if (routeInfo.type === \"redirect-internal\") {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent(\"/404\");\n                        notFoundRoute = \"/404\";\n                    } catch (_) {\n                        notFoundRoute = \"/_error\";\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if (\"type\" in routeInfo) {\n                        throw new Error(\"Unexpected middleware effect on /404\");\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            var _routeInfo_route;\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n            var _options_scroll;\n            const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if (\"type\" in routeInfo) {\n                    throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n                }\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (process.env.__NEXT_I18N_SUPPORT) {\n                    if (nextState.locale) {\n                        document.documentElement.lang = nextState.locale;\n                    }\n                }\n                if (!isQueryUpdating) {\n                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options) {\n        if (options === void 0) options = {};\n        if (process.env.NODE_ENV !== \"production\") {\n            if (typeof window.history === \"undefined\") {\n                console.error(\"Warning: window.history is not available.\");\n                return;\n            }\n            if (typeof window.history[method] === \"undefined\") {\n                console.error(\"Warning: window.history.\" + method + \" is not available\");\n                return;\n            }\n        }\n        if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== \"pushState\" ? this._key : createKey()\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/docs/Web/API/History/replaceState\n            \"\", as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        console.error(err);\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit(\"routeChangeError\", err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent(\"/_error\");\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(param) {\n        let { route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound } = param;\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            var _data_effect, _data_effect1, _data_effect2, _data_response;\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && process.env.NODE_ENV !== \"development\" ? existingInfo : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? \"/404\" : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                return data.effect;\n            }\n            if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\") {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (process.env.NODE_ENV !== \"production\") {\n                const { isValidElementType } = require(\"next/dist/compiled/react-is\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                }\n            }\n            const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                    {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && process.env.NODE_ENV !== \"development\" && !isQueryUpdating) {\n                fetchNextData(Object.assign({}, fetchNextDataParams, {\n                    isBackground: true,\n                    persistCache: false,\n                    inflightCache: this.sbc\n                })).catch(()=>{});\n            }\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\");\n        const [newUrlNoHash, newHash] = as.split(\"#\");\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = \"\"] = as.split(\"#\");\n        (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === \"\" || hash === \"top\") {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath, options) {\n        if (asPath === void 0) asPath = url;\n        if (options === void 0) options = {};\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (process.env.NODE_ENV !== \"production\") {\n            return;\n        }\n        if (typeof window !== \"undefined\" && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            if (options.locale === false) {\n                pathname = (0, _normalizelocalepath.normalizeLocalePath)(pathname, this.locales).pathname;\n                parsed.pathname = pathname;\n                url = (0, _formaturl.formatWithValidation)(parsed);\n                let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n                const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n                parsedAs.pathname = localePathResult.pathname;\n                options.locale = localePathResult.detectedLocale || this.defaultLocale;\n                asPath = (0, _formaturl.formatWithValidation)(parsedAs);\n            }\n        }\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith(\"/\")) {\n            let rewrites;\n            ({ __rewrites: rewrites } = await (0, _routeloader.getClientBuildManifest)());\n            const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages), this.locales);\n            if (rewritesResult.externalDest) {\n                return;\n            }\n            if (!isMiddlewareMatch) {\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n            }\n            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n                if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n            }\n        }\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === \"strict\" ? null : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: this.isSsr,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error(\"Loading initial props cancelled\");\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then((param)=>{\n            let { text } = param;\n            return {\n                data: text\n            };\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components[\"/_app\"];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._key !== key) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem(\"__next_scroll_\" + this._key, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch (e) {}\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem(\"__next_scroll_\" + key);\n                            forcedScroll = JSON.parse(v);\n                        } catch (e) {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n            const { BloomFilter } = require(\"../../lib/bloom-filter\");\n            const staticFilterData = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;\n            const dynamicFilterData = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s.import(staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d.import(dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!(0, _detectdomainlocale.detectDomainLocale)(domainLocales, self.location.hostname);\n        }\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (typeof window !== \"undefined\") {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = \"manual\";\n                }\n            }\n        }\n    }\n}\nRouter.events = (0, _mitt.default)();\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}