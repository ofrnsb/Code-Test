{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getPathMatch\", {\n  enumerable: true,\n  get: function () {\n    return getPathMatch;\n  }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n  const keys = [];\n  const regexp = (0, _pathtoregexp.pathToRegexp)(path, keys, {\n    delimiter: \"/\",\n    sensitive: typeof (options == null ? void 0 : options.sensitive) === \"boolean\" ? options.sensitive : false,\n    strict: options == null ? void 0 : options.strict\n  });\n  const matcher = (0, _pathtoregexp.regexpToFunction)((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n  /**\n  * A matcher function that will check if a given pathname matches the path\n  * given in the builder function. When the path does not match it will return\n  * `false` but if it does it will return an object with the matched params\n  * merged with the params provided in the second argument.\n  */\n  return (pathname, params) => {\n    // If no pathname is provided it's not a match.\n    if (typeof pathname !== \"string\") return false;\n    const match = matcher(pathname);\n    // If the path did not match `false` will be returned.\n    if (!match) return false;\n    /**\n    * If unnamed params are not allowed they must be removed from\n    * the matched parameters. path-to-regexp uses \"string\" for named and\n    * \"number\" for unnamed parameters.\n    */\n    if (options == null ? void 0 : options.removeUnnamedParams) {\n      for (const key of keys) {\n        if (typeof key.name === \"number\") {\n          delete match.params[key.name];\n        }\n      }\n    }\n    return {\n      ...params,\n      ...match.params\n    };\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","getPathMatch","_pathtoregexp","require","path","options","keys","regexp","pathToRegexp","delimiter","sensitive","strict","matcher","regexpToFunction","regexModifier","RegExp","source","flags","pathname","params","match","removeUnnamedParams","key","name"],"sources":["C:/Users/BNI/node_modules/next/dist/shared/lib/router/utils/path-match.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getPathMatch\", {\n    enumerable: true,\n    get: function() {\n        return getPathMatch;\n    }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n    const keys = [];\n    const regexp = (0, _pathtoregexp.pathToRegexp)(path, keys, {\n        delimiter: \"/\",\n        sensitive: typeof (options == null ? void 0 : options.sensitive) === \"boolean\" ? options.sensitive : false,\n        strict: options == null ? void 0 : options.strict\n    });\n    const matcher = (0, _pathtoregexp.regexpToFunction)((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n    /**\n   * A matcher function that will check if a given pathname matches the path\n   * given in the builder function. When the path does not match it will return\n   * `false` but if it does it will return an object with the matched params\n   * merged with the params provided in the second argument.\n   */ return (pathname, params)=>{\n        // If no pathname is provided it's not a match.\n        if (typeof pathname !== \"string\") return false;\n        const match = matcher(pathname);\n        // If the path did not match `false` will be returned.\n        if (!match) return false;\n        /**\n     * If unnamed params are not allowed they must be removed from\n     * the matched parameters. path-to-regexp uses \"string\" for named and\n     * \"number\" for unnamed parameters.\n     */ if (options == null ? void 0 : options.removeUnnamedParams) {\n            for (const key of keys){\n                if (typeof key.name === \"number\") {\n                    delete match.params[key.name];\n                }\n            }\n        }\n        return {\n            ...params,\n            ...match.params\n        };\n    };\n}\n\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,cAAc,EAAE;EAC3CE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,OAAOC,YAAY;EACvB;AACJ,CAAC,CAAC;AACF,MAAMC,aAAa,GAAGC,OAAO,CAAC,mCAAmC,CAAC;AAClE,SAASF,YAAYA,CAACG,IAAI,EAAEC,OAAO,EAAE;EACjC,MAAMC,IAAI,GAAG,EAAE;EACf,MAAMC,MAAM,GAAG,CAAC,CAAC,EAAEL,aAAa,CAACM,YAAY,EAAEJ,IAAI,EAAEE,IAAI,EAAE;IACvDG,SAAS,EAAE,GAAG;IACdC,SAAS,EAAE,QAAQL,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACK,SAAS,CAAC,KAAK,SAAS,GAAGL,OAAO,CAACK,SAAS,GAAG,KAAK;IAC1GC,MAAM,EAAEN,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACM;EAC/C,CAAC,CAAC;EACF,MAAMC,OAAO,GAAG,CAAC,CAAC,EAAEV,aAAa,CAACW,gBAAgB,EAAE,CAACR,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACS,aAAa,IAAI,IAAIC,MAAM,CAACV,OAAO,CAACS,aAAa,CAACP,MAAM,CAACS,MAAM,CAAC,EAAET,MAAM,CAACU,KAAK,CAAC,GAAGV,MAAM,EAAED,IAAI,CAAC;EACvL;AACJ;AACA;AACA;AACA;AACA;EAAM,OAAO,CAACY,QAAQ,EAAEC,MAAM,KAAG;IACzB;IACA,IAAI,OAAOD,QAAQ,KAAK,QAAQ,EAAE,OAAO,KAAK;IAC9C,MAAME,KAAK,GAAGR,OAAO,CAACM,QAAQ,CAAC;IAC/B;IACA,IAAI,CAACE,KAAK,EAAE,OAAO,KAAK;IACxB;AACR;AACA;AACA;AACA;IAAQ,IAAIf,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACgB,mBAAmB,EAAE;MACxD,KAAK,MAAMC,GAAG,IAAIhB,IAAI,EAAC;QACnB,IAAI,OAAOgB,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;UAC9B,OAAOH,KAAK,CAACD,MAAM,CAACG,GAAG,CAACC,IAAI,CAAC;QACjC;MACJ;IACJ;IACA,OAAO;MACH,GAAGJ,MAAM;MACT,GAAGC,KAAK,CAACD;IACb,CAAC;EACL,CAAC;AACL"},"metadata":{},"sourceType":"script","externalDependencies":[]}