{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"interpolateAs\", {\n  enumerable: true,\n  get: function () {\n    return interpolateAs;\n  }\n});\nconst _routematcher = require(\"./route-matcher\");\nconst _routeregex = require(\"./route-regex\");\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = \"\";\n  const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches =\n  // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") ||\n  // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || \"\";\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param];\n    // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n    let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n    if (optional) {\n      replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n    }\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && (\n    // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(\n    // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n  })) {\n    interpolatedRoute = \"\" // did not satisfy all requirements\n    ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","interpolateAs","_routematcher","require","_routeregex","route","asPathname","query","interpolatedRoute","dynamicRegex","getRouteRegex","dynamicGroups","groups","dynamicMatches","getRouteMatcher","params","keys","every","param","repeat","optional","replaced","Array","isArray","replace","map","segment","encodeURIComponent","join","result"],"sources":["C:/Users/BNI/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"interpolateAs\", {\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n});\nconst _routematcher = require(\"./route-matcher\");\nconst _routeregex = require(\"./route-regex\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = // Try to match the dynamic route against the asPath\n    (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just\n        // path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\n\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,eAAe,EAAE;EAC5CE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,OAAOC,aAAa;EACxB;AACJ,CAAC,CAAC;AACF,MAAMC,aAAa,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAMC,WAAW,GAAGD,OAAO,CAAC,eAAe,CAAC;AAC5C,SAASF,aAAaA,CAACI,KAAK,EAAEC,UAAU,EAAEC,KAAK,EAAE;EAC7C,IAAIC,iBAAiB,GAAG,EAAE;EAC1B,MAAMC,YAAY,GAAG,CAAC,CAAC,EAAEL,WAAW,CAACM,aAAa,EAAEL,KAAK,CAAC;EAC1D,MAAMM,aAAa,GAAGF,YAAY,CAACG,MAAM;EACzC,MAAMC,cAAc;EAAG;EACvB,CAACP,UAAU,KAAKD,KAAK,GAAG,CAAC,CAAC,EAAEH,aAAa,CAACY,eAAe,EAAEL,YAAY,CAAC,CAACH,UAAU,CAAC,GAAG,EAAE;EAAK;EAC9F;EACAC,KAAK;EACLC,iBAAiB,GAAGH,KAAK;EACzB,MAAMU,MAAM,GAAGpB,MAAM,CAACqB,IAAI,CAACL,aAAa,CAAC;EACzC,IAAI,CAACI,MAAM,CAACE,KAAK,CAAEC,KAAK,IAAG;IACvB,IAAIpB,KAAK,GAAGe,cAAc,CAACK,KAAK,CAAC,IAAI,EAAE;IACvC,MAAM;MAAEC,MAAM;MAAEC;IAAS,CAAC,GAAGT,aAAa,CAACO,KAAK,CAAC;IACjD;IACA;IACA,IAAIG,QAAQ,GAAG,GAAG,IAAIF,MAAM,GAAG,KAAK,GAAG,EAAE,CAAC,GAAGD,KAAK,GAAG,GAAG;IACxD,IAAIE,QAAQ,EAAE;MACVC,QAAQ,GAAG,CAAC,CAACvB,KAAK,GAAG,GAAG,GAAG,EAAE,IAAI,GAAG,GAAGuB,QAAQ,GAAG,GAAG;IACzD;IACA,IAAIF,MAAM,IAAI,CAACG,KAAK,CAACC,OAAO,CAACzB,KAAK,CAAC,EAAEA,KAAK,GAAG,CACzCA,KAAK,CACR;IACD,OAAO,CAACsB,QAAQ,IAAIF,KAAK,IAAIL,cAAc;IAAK;IAC/CL,iBAAiB,GAAGA,iBAAiB,CAACgB,OAAO,CAACH,QAAQ,EAAEF,MAAM,GAAGrB,KAAK,CAAC2B,GAAG;IAAC;IAC5E;IACA;IACA;IACCC,OAAO,IAAGC,kBAAkB,CAACD,OAAO,CAAC,CAAC,CAACE,IAAI,CAAC,GAAG,CAAC,GAAGD,kBAAkB,CAAC7B,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC;EAC1F,CAAC,CAAC,EAAE;IACAU,iBAAiB,GAAG,EAAE,CAAC;IAAA;IAE3B;IACA;EACA;;EACA,OAAO;IACHO,MAAM;IACNc,MAAM,EAAErB;EACZ,CAAC;AACL"},"metadata":{},"sourceType":"script","externalDependencies":[]}