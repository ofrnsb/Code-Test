{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return resolveRewrites;\n  }\n});\nconst _pathmatch = require(\"./path-match\");\nconst _preparedestination = require(\"./prepare-destination\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\nconst _normalizelocalepath = require(\"../../i18n/normalize-locale-path\");\nconst _removebasepath = require(\"../../../../client/remove-base-path\");\nconst _parserelativeurl = require(\"./parse-relative-url\");\nfunction resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {\n  let matchedPage = false;\n  let externalDest = false;\n  let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n  let fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedAs.pathname), locales).pathname);\n  let resolvedHref;\n  const handleRewrite = rewrite => {\n    const matcher = (0, _pathmatch.getPathMatch)(rewrite.source + (process.env.__NEXT_TRAILING_SLASH ? \"(/)?\" : \"\"), {\n      removeUnnamedParams: true,\n      strict: true\n    });\n    let params = matcher(parsedAs.pathname);\n    if ((rewrite.has || rewrite.missing) && params) {\n      const hasParams = (0, _preparedestination.matchHas)({\n        headers: {\n          host: document.location.hostname,\n          \"user-agent\": navigator.userAgent\n        },\n        cookies: document.cookie.split(\"; \").reduce((acc, item) => {\n          const [key, ...value] = item.split(\"=\");\n          acc[key] = value.join(\"=\");\n          return acc;\n        }, {})\n      }, parsedAs.query, rewrite.has, rewrite.missing);\n      if (hasParams) {\n        Object.assign(params, hasParams);\n      } else {\n        params = false;\n      }\n    }\n    if (params) {\n      if (!rewrite.destination) {\n        // this is a proxied rewrite which isn't handled on the client\n        externalDest = true;\n        return true;\n      }\n      const destRes = (0, _preparedestination.prepareDestination)({\n        appendParamsToQuery: true,\n        destination: rewrite.destination,\n        params: params,\n        query: query\n      });\n      parsedAs = destRes.parsedDestination;\n      asPath = destRes.newUrl;\n      Object.assign(query, destRes.parsedDestination.query);\n      fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(asPath), locales).pathname);\n      if (pages.includes(fsPathname)) {\n        // check if we now match a page as this means we are done\n        // resolving the rewrites\n        matchedPage = true;\n        resolvedHref = fsPathname;\n        return true;\n      }\n      // check if we match a dynamic-route, if so we break the rewrites chain\n      resolvedHref = resolveHref(fsPathname);\n      if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n        matchedPage = true;\n        return true;\n      }\n    }\n  };\n  let finished = false;\n  for (let i = 0; i < rewrites.beforeFiles.length; i++) {\n    // we don't end after match in beforeFiles to allow\n    // continuing through all beforeFiles rewrites\n    handleRewrite(rewrites.beforeFiles[i]);\n  }\n  matchedPage = pages.includes(fsPathname);\n  if (!matchedPage) {\n    if (!finished) {\n      for (let i = 0; i < rewrites.afterFiles.length; i++) {\n        if (handleRewrite(rewrites.afterFiles[i])) {\n          finished = true;\n          break;\n        }\n      }\n    }\n    // check dynamic route before processing fallback rewrites\n    if (!finished) {\n      resolvedHref = resolveHref(fsPathname);\n      matchedPage = pages.includes(resolvedHref);\n      finished = matchedPage;\n    }\n    if (!finished) {\n      for (let i = 0; i < rewrites.fallback.length; i++) {\n        if (handleRewrite(rewrites.fallback[i])) {\n          finished = true;\n          break;\n        }\n      }\n    }\n  }\n  return {\n    asPath,\n    parsedAs,\n    matchedPage,\n    resolvedHref,\n    externalDest\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","resolveRewrites","_pathmatch","require","_preparedestination","_removetrailingslash","_normalizelocalepath","_removebasepath","_parserelativeurl","asPath","pages","rewrites","query","resolveHref","locales","matchedPage","externalDest","parsedAs","parseRelativeUrl","fsPathname","removeTrailingSlash","normalizeLocalePath","removeBasePath","pathname","resolvedHref","handleRewrite","rewrite","matcher","getPathMatch","source","process","env","__NEXT_TRAILING_SLASH","removeUnnamedParams","strict","params","has","missing","hasParams","matchHas","headers","host","document","location","hostname","navigator","userAgent","cookies","cookie","split","reduce","acc","item","key","join","assign","destination","destRes","prepareDestination","appendParamsToQuery","parsedDestination","newUrl","includes","finished","i","beforeFiles","length","afterFiles","fallback"],"sources":["C:/Users/BNI/node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return resolveRewrites;\n    }\n});\nconst _pathmatch = require(\"./path-match\");\nconst _preparedestination = require(\"./prepare-destination\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\nconst _normalizelocalepath = require(\"../../i18n/normalize-locale-path\");\nconst _removebasepath = require(\"../../../../client/remove-base-path\");\nconst _parserelativeurl = require(\"./parse-relative-url\");\nfunction resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {\n    let matchedPage = false;\n    let externalDest = false;\n    let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n    let fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedAs.pathname), locales).pathname);\n    let resolvedHref;\n    const handleRewrite = (rewrite)=>{\n        const matcher = (0, _pathmatch.getPathMatch)(rewrite.source + (process.env.__NEXT_TRAILING_SLASH ? \"(/)?\" : \"\"), {\n            removeUnnamedParams: true,\n            strict: true\n        });\n        let params = matcher(parsedAs.pathname);\n        if ((rewrite.has || rewrite.missing) && params) {\n            const hasParams = (0, _preparedestination.matchHas)({\n                headers: {\n                    host: document.location.hostname,\n                    \"user-agent\": navigator.userAgent\n                },\n                cookies: document.cookie.split(\"; \").reduce((acc, item)=>{\n                    const [key, ...value] = item.split(\"=\");\n                    acc[key] = value.join(\"=\");\n                    return acc;\n                }, {})\n            }, parsedAs.query, rewrite.has, rewrite.missing);\n            if (hasParams) {\n                Object.assign(params, hasParams);\n            } else {\n                params = false;\n            }\n        }\n        if (params) {\n            if (!rewrite.destination) {\n                // this is a proxied rewrite which isn't handled on the client\n                externalDest = true;\n                return true;\n            }\n            const destRes = (0, _preparedestination.prepareDestination)({\n                appendParamsToQuery: true,\n                destination: rewrite.destination,\n                params: params,\n                query: query\n            });\n            parsedAs = destRes.parsedDestination;\n            asPath = destRes.newUrl;\n            Object.assign(query, destRes.parsedDestination.query);\n            fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(asPath), locales).pathname);\n            if (pages.includes(fsPathname)) {\n                // check if we now match a page as this means we are done\n                // resolving the rewrites\n                matchedPage = true;\n                resolvedHref = fsPathname;\n                return true;\n            }\n            // check if we match a dynamic-route, if so we break the rewrites chain\n            resolvedHref = resolveHref(fsPathname);\n            if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n                matchedPage = true;\n                return true;\n            }\n        }\n    };\n    let finished = false;\n    for(let i = 0; i < rewrites.beforeFiles.length; i++){\n        // we don't end after match in beforeFiles to allow\n        // continuing through all beforeFiles rewrites\n        handleRewrite(rewrites.beforeFiles[i]);\n    }\n    matchedPage = pages.includes(fsPathname);\n    if (!matchedPage) {\n        if (!finished) {\n            for(let i = 0; i < rewrites.afterFiles.length; i++){\n                if (handleRewrite(rewrites.afterFiles[i])) {\n                    finished = true;\n                    break;\n                }\n            }\n        }\n        // check dynamic route before processing fallback rewrites\n        if (!finished) {\n            resolvedHref = resolveHref(fsPathname);\n            matchedPage = pages.includes(resolvedHref);\n            finished = matchedPage;\n        }\n        if (!finished) {\n            for(let i = 0; i < rewrites.fallback.length; i++){\n                if (handleRewrite(rewrites.fallback[i])) {\n                    finished = true;\n                    break;\n                }\n            }\n        }\n    }\n    return {\n        asPath,\n        parsedAs,\n        matchedPage,\n        resolvedHref,\n        externalDest\n    };\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}